-----------------------------------------------------------
ATOM を二つに分けた
	cxr 内で判断できるもの。
		これは SHORT_NUM と nil しかない。
	あとは cxr がポインターになる。
		ポインターの先に情報がある。
ATOM でないもの
	これはリスト(nilを除く)だ。だから
	ポインターになる

ポインター
	ポインターは下位3bitが 0 なのでこれでわかる。
	ポインターには２種類ある

	ATOM と リスト
	ATOM は cxr ないで判断できない atom なので
	ex_entity と命名した。

	当初、ExEntity を指すときは
	cxr としては ATOM をすぐに判断したいので
	cxr 内にフラグを入れていた。
	cxr は B001 が ex_entity で B000 がリスト
	しかし、値自体は C のポインターなので

	ex_entity *ptr = cxr & PINTER_MASK
	みたいなことをしていた。
	(explicit operator pair_cell *(); フラグを落としていた)

	これにより ATOM かどうかすぐに判断できると考えた。
	しかし、プログラムで扱うときは上のように
	強引にキャストする処理が必ず入る。
	全体として見通しも悪く、ときどき、プログラムを間違えて
	キャストしそこない、下位1bit が 1 になるということが起こった。
	ASSERT などをいれておけば問題は早期に発見できるが、
	結果として処理スピードが速くならない気がしてきた。

	見通しを優先するために、ポインタの先をみて
	ex_entity か list かを判断するようにした。

	これにより素直なキャストになった。

--------------------------------------
揮発性
	gc で移動する可能性があるものは揮発性と命名した。
	class 内で保持するといつの間にか gc で移動している。
	なので、揮発性物は保持してはならない。


--------------------------------------
揮発性の Wrapper 
	gc 
	揮発性のものは Wrapper として util ルーチンを作ってもよい。
	というルールにした。
	src/ExAllocator.h
	src/ExAtom.h
	src/ExBigNum.h
	src/ExChar.h
	src/ExExNum.h
	src/ExRoot.h
	src/ExString.h
	src/ExSymbol.h
	src/ExValue.h
	がそれ union で構造を明確にしている。つもり。

ExAllocator は特別。
	プログラム内で ExAllocator のポインターを知る必要があった。
	グローバルにすると複数の allocator を共存させることができない。

揮発性の Environment
	当初、揮発性の EnvironmentWrapper なるものをつくっていた。
	しかし、その後、 これは全部 lisp 内に収めたため削った。
	が、似たような Environment.h を復活させた。
	Environment は揮発性である。
	しかし、Environment 自身は処理がいろいろあり
	比較的長い処理もあるのでクラス化した。
	namespace 化した方が良かったかもしれない。
--------------------------------------
alloc の連続領域管理
	とりあえずつくった。
	vector は malloc できない。そうすると gc の対象にならないから
	結局 ずべて lisp の世界にする必要がある。
	Allocator だけ別の世界にあるのこころ。

	ExAtom の領域管理 たとえば Symbol の領域
		malloc では gc の対象いならない。
		Symbol などの領域が gc を機会に宙ぶらりんになる。
		なぜなら gc でいらなくなった領域の先に
		Symbol などがついていたばあい
		gc で移動しないためフリーするを失う。
		
		他の方法として 単純に gc で最後に巡回し、
		いらなくなったとおもわれるポインタの先について
		delete すればいいが、その場合、多重にポイントされていた場合
		だめ。つまりリファレンスカウンターが必要
		リファレンスカウンターはgc の変形でしかないので
		統一的な gc がもとめられる。

		いろいろ考えると、すべてをlisp に含め
		gc 対象にしないといけない。

	つまり連続領域が必要になったので実装した。
--------------------------------------
ex_entity の後続する length 
	下位1bit が 1 なら length, 0 ならポインタ。
	ポインターの場合は gc 対象にならない。
	length なら後続する pair_cell が領域。
	後続する長さをいれこみたいので LENGTH_SHIFT 分右にシフト
	すると長さとした。LENGTH_SHIFT は 4。
	これは 64bit のポインタの２個分＝16byte で
	それは 2^4 = 16 だから。って意味があまりないかも。

--------------------------------------
エラーを分類する必要がある。
	実行中の alloc エラー
		>> 戻しようがないので fatal_error
			デバッグ時に補足できるべき？

	fatal_error
		>> 終了
			解析できるようにすべき？

	syntax_error
		>> プロンプトまで戻す。

	eof
		>> repl 終了
